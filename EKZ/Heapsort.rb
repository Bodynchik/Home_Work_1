# heapify додаткова функція для перетворення на двійкову купу піддерева з вузлом i
def heapify(arr, n, i)
  largest = i

  # Ініціалізуємо найбільший елемент як корінь
  left = 2 * i + 1
  right = 2 * i + 2

  # Виконання умови якщо лівий дочірній елемент більше кореня
  if left < n && arr[left] > arr[largest]
    largest = left
  end

  # Виконання умови якщо правий дочірній елемент більше кореня
  if right < n && arr[right] > arr[largest]
    largest = right
  end

  # Виконання умови якщо найбільший елемент не корінь
  if largest != i
    arr[i], arr[largest] = arr[largest], arr[i]

    # Виклик рекурсивної функції для перетворення на двійкову купу піддерева
    heapify(arr, n, largest)
  end
end

# Основна функція, яка виконує пірамідальне сортування
def heap_sort(arr)

  # Проходить через всі нелистові вузли дерева (елементи масиву, які мають дочірні елементи) у зворотньому порядку,
  # починаючи з останнього нелистового вузла і закінчуючи коренем дерева (індекс 0).
  (arr.length / 2 - 1).downto(0) do |i|
    heapify(arr, arr.length, i)
  end

  # Проходить через масив, починаючи з кінця і переміщаючи кожен найбільший елемент в кінець масиву.
  (arr.length - 1).downto(1) do |i|
    arr[0], arr[i] = arr[i], arr[0]
    heapify(arr, i, 0)
  end
end

arr = [34, 0, 3, 7, -5, 1, 55]
puts "Масив до сортування: #{arr}"
heap_sort(arr)
puts "Масив після сортування: #{arr}"